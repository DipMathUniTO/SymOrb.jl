"""
    ϕg_n(v::Config, n::Int)::Config

Action of the n-th power of g ∈ G on v ∈ ℝᵈᴺ 
"""
ϕg_n(v::Config, n::Int)::Config = 
    if (length(G.g) > 1)
        ϕ(G.g[n], v)
    else
        v
    end

"""
    ϕg_inv(v::Config)::Config

Action of the inverse of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg_inv(v::Config)::Config = ϕg_n(v, length(G.g) -1)

"""
   ϕg(v::Config)::Config 

Action of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg(v::Config)::Config = ϕg_n(v, 1)

"""
    ϕ(h::GroupElement, v::Config)::Config

Action of h ∈ H on v ∈ ℝᵈ
"""
ϕ(h::GroupElement, v::Config)::Config =
    [h.M * v[h.σ[i]] for i ∈ axes(h.σ, 1)]


""" 
    π_c(v::Config)::Config

Projection onto the center of mass
"""
π_c(v::Config)::Config =  begin
    xc = sum(m[i] * v[i] for i ∈ axes(m, 1)) / sum(m)

    return [v[i] - xc for i ∈ axes(m,1)]
end

"""
    π_H(H::Vector{GroupElement}, v::Config)::Config

Projection onto the subspace spanned by the action of H on v
"""
π_H(H::Vector{GroupElement}, v::Config)::Config =
    sum(ϕ(H[i], v) for i ∈ axes(H, 1)) / length(H)

"""
    π_H(H::GroupElement, v::Config) 

Projection onto the subspace generated by a single H
"""
π_H(H::GroupElement, v::Config) = (v + ϕ(H, v))/2


"""
    π_kerT(v::Config)::Config

Projection onto ker_T
"""
π_kerT(v::Config)::Config = π_H(G.kerT, v)


"""
    π_a(v::Config, w::Config)::Tuple{Config,Config}

Project the extremities `v, w` of a path
"""
π_a(v::Config, w::Config)::Tuple{Config,Config} =
    if (G.action_type == Cyclic)
        ((v + ϕg_inv(w)) / 2,  (w + ϕg(v)) / 2)
    else
        ( π_H(G.H0, v), π_H(G.H1, w)  )
    end

""" 
    project(A::Coefficients)::Coefficients

Project the whole path
"""
function project(A::Coefficients)::Coefficients
    (A[0], A[F+1]) = π_a(A[0], A[F+1])
    A = π_kerT.(π_c.(A))
end

"""
    project(H::OffsetMatrix)::OffsetMatrix

Project a matrix projecting each of its rows and columns
"""
function project(H::OffsetMatrix{Matrix{Matrix{Float64}}})::OffsetMatrix{Matrix{Matrix{Float64}}}

    for k ∈ 0:F+1, i ∈ 1:N, d ∈ 1:dim
        slice = FromZero([[[ H[k1,k][i1,i][d1,d] for d1 ∈ 1:dim] for i1 ∈ 1:N ] for k1 ∈ 0:F+1])
        slice = project(slice)
        for k1 ∈ 0:F+1, i1 ∈ 1:N
            H[k1,k][i1,i][:, d] = slice[k1][i1]
            H[k,k1][i,i1][d, :] = slice[k1][i1]
        end    
    end
    return H
end