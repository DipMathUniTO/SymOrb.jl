"""
    ϕg_n(v::Config, n::Int)::Config

Action of the n-th power of g ∈ G on v ∈ ℝᵈᴺ 
"""
ϕg_n(g::Vector{GroupElement}, v::Config, n::Int)::Config = 
    if (length(g) > 1)
        ϕ(g[n], v)
    else
        v
    end

"""
    ϕg_inv(v::Config)::Config

Action of the inverse of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg_inv(g::Vector{GroupElement}, v::Config)::Config = ϕg_n(g, v, length(g) -1)

"""
   ϕg(v::Config)::Config 

Action of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg(g::Vector{GroupElement}, v::Config)::Config = ϕg_n(g, v, 1)

"""
    ϕ(h::GroupElement, v::Config)::Config

Action of h ∈ H on v ∈ ℝᵈ
"""
ϕ(h::GroupElement, v::Config)::Config = [h.M * v[h.σ[i]] for i ∈ axes(h.σ, 1)]


""" 
    π_c(v::Config)::Config

Projection onto the center of mass
"""
π_c(m::Vector{Float64}, v::Config)::Config =  begin
    xc = sum( m .* v ) / sum(m)
    [v[i] - xc for i ∈ axes(m,1)]
end

"""
    π_H(H::Vector{GroupElement}, v::Config)::Config

Projection onto the subspace spanned by the action of H on v
"""
π_H(H::Vector{GroupElement}, v::Config)::Config =
    sum(ϕ(H[i], v) for i ∈ axes(H, 1)) / length(H)

"""
    π_H(H::GroupElement, v::Config) 

Projection onto the subspace generated by a single H
"""
π_H(H::GroupElement, v::Config) = (v + ϕ(H, v))/2


"""
    π_a(v::Config, w::Config)::Tuple{Config,Config}

Project the extremities `v, w` of a path
"""
π_bc(G::SymmetryGroup, v::Config, w::Config)::Tuple =
    if (G.action_type == Cyclic)
        ((v + ϕg_inv(G.g, w)) / 2,  (w + ϕg(G.g, v)) / 2)
    else
        ( π_H(G.H0, v), π_H(G.H1, w)  )
    end

""" 
    project(A::Coefficients)::Coefficients

Project the whole path
"""
function project(p::Problem, A::Coefficients)::Coefficients
    π_kerT = v -> π_H(p.G.kerT, v)
    _π_c = v -> π_c(p.m, v)
    A[0], A[end] = π_bc(p.G, A[0], A[end])
    A .= π_kerT.(_π_c.(A))
end

"""
    project(H::OffsetMatrix)::OffsetMatrix

Project a symmetric matrix projecting each of its rows and columns
"""
function project(p::Problem, M::OffsetMatrix{Matrix{Matrix{Float64}}})::OffsetMatrix{Matrix{Matrix{Float64}}}
    d = dims(M)
    M_flat = flatten(M)

    _project = x -> project(p, x)

    # Project each row and column of the matrix
    M_flat .= mapslices(x -> (flatten ∘ _project ∘ emboss)(x, d), M_flat, dims=1)
    M_flat .= mapslices(x -> (flatten ∘ _project ∘ emboss)(x, d), M_flat, dims=2)

    # Symmetrize the matrix
    M_flat .= (M_flat .+ M_flat') /  2

    # Reshape the matrix
    M = emboss(M_flat, d)
    return M

end