"""
    ϕg_n(v::Config, n::Int)::Config

Action of the n-th power of g ∈ G on v ∈ ℝᵈᴺ 
"""
ϕg_n(g::Vector{GroupElement}, v::Config, n::Int)::Config = 
    if (length(g) > 1)
        ϕ(g[n], v)
    else
        v
    end

"""
    ϕg_inv(v::Config)::Config

Action of the inverse of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg_inv(g::Vector{GroupElement}, v::Config)::Config = ϕg_n(g, v, length(g) -1)

"""
   ϕg(v::Config)::Config 

Action of g ∈ G on v ∈ ℝᵈᴺ
"""
ϕg(g::Vector{GroupElement}, v::Config)::Config = ϕg_n(g, v, 1)

"""
    ϕ(h::GroupElement, v::Config)::Config

Action of h ∈ H on v ∈ ℝᵈ
"""
ϕ(h::GroupElement, v::Config)::Config = [h.M * v[h.σ[i]] for i ∈ axes(h.σ, 1)]


""" 
    π_c(v::Config)::Config

Projection onto the center of mass
"""
π_c(m::Vector{Float64}, v::Config)::Config =  begin
    xc = sum(m[i] * v[i] for i ∈ axes(m, 1)) / sum(m)
    [v[i] - xc for i ∈ axes(m,1)]
end

"""
    π_H(H::Vector{GroupElement}, v::Config)::Config

Projection onto the subspace spanned by the action of H on v
"""
π_H(H::Vector{GroupElement}, v::Config)::Config =
    sum(ϕ(H[i], v) for i ∈ axes(H, 1)) / length(H)

"""
    π_H(H::GroupElement, v::Config) 

Projection onto the subspace generated by a single H
"""
π_H(H::GroupElement, v::Config) = (v + ϕ(H, v))/2


"""
    π_a(v::Config, w::Config)::Tuple{Config,Config}

Project the extremities `v, w` of a path
"""
π_bc(G::SymmetryGroup, v::Config, w::Config)::Tuple{Config,Config} =
    if (G.action_type == Cyclic)
        ((v + ϕg_inv(G.g, w)) / 2,  (w + ϕg(G.g, v)) / 2)
    else
        ( π_H(G.H0, v), π_H(G.H1, w)  )
    end

""" 
    project(A::Coefficients)::Coefficients

Project the whole path
"""
function project(p::Problem, A::Coefficients)::Coefficients
    π_kerT = v -> π_H(p.G.kerT, v)
    _π_c = v -> π_c(p.m, v)
    (A[0], A[end]) = π_bc(p.G, A[0], A[end])
    A = π_kerT.(_π_c.(A))
end

"""
    project(H::OffsetMatrix)::OffsetMatrix

Project a matrix projecting each of its rows and columns
"""
function project(p::Problem, M::OffsetMatrix{Matrix{Matrix{Float64}}})::OffsetMatrix{Matrix{Matrix{Float64}}}
    F = lastindex(M, 1)-1
    N = lastindex(M[end, end], 1)
    dim = lastindex(M[end, end][end, end], 1)

    for k ∈ 0:F+1, i ∈ 1:N, d ∈ 1:dim
        slice = FromZero([[[ M[k1,k][i1,i][d1,d] for d1 ∈ 1:dim] for i1 ∈ 1:N ] for k1 ∈ 0:F+1])
        slice = project(p, slice)
        for k1 ∈ 0:F+1, i1 ∈ 1:N
            M[k1,k][i1,i][:, d] = slice[k1][i1]
            M[k,k1][i,i1][d, :] = slice[k1][i1]
        end    
    end
    return M
end